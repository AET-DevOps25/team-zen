# This workflow manages Terraform infrastructure deployment and validation
name: Infrastructure

on:
  pull_request:
    paths:
      - "**/*.tf"
      - "infra/**"
      - ".github/workflows/infrastructure.yml"
  push:
    branches:
      - feat/aws-deployment  # Temporary for testing
    paths:
      - "**/*.tf"
      - "infra/**"
      - ".github/workflows/infrastructure.yml"
  workflow_dispatch:
    inputs:
      action:
        description: "Terraform action to perform"
        required: false
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy

permissions:
  contents: read
  pull-requests: write

jobs:
  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infra
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
      AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION }}

    outputs:
      ec2_public_ip: ${{ steps.terraform_outputs.outputs.ec2_public_ip }}
      ec2_instance_id: ${{ steps.terraform_outputs.outputs.ec2_instance_id }}
      infrastructure_deployed: ${{ steps.terraform_outputs.outputs.infrastructure_deployed }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.2
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ vars.AWS_DEFAULT_REGION }}

      - name: Cache Terraform
        uses: actions/cache@v3
        with:
          path: infra/.terraform
          key: terraform-${{ hashFiles('infra/**/*.tf') }}

      - name: Terraform fmt
        id: fmt
        run: terraform fmt -check
        continue-on-error: true

      - name: Terraform Init
        id: init
        run: |
          # Configuration
          BUCKET_NAME="zenai-terraform-state-bucket"
          REGION="us-east-1"
          
          echo "ğŸ” Checking if S3 bucket exists..."
          
          # Check if bucket exists
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "âœ… S3 bucket '$BUCKET_NAME' already exists"
            BUCKET_EXISTS=true
          else
            echo "âŒ S3 bucket '$BUCKET_NAME' does not exist"
            BUCKET_EXISTS=false
          fi
          
          # Try terraform init first
          echo "ğŸš€ Attempting terraform initialization..."
          if terraform init -input=false; then
            echo "âœ… Terraform initialization successful"
          else
            echo "âŒ Terraform initialization failed"
            
            if [ "$BUCKET_EXISTS" = false ]; then
              echo "ğŸ“¦ Creating S3 bucket for Terraform state storage..."
              
              # Create the bucket
              if aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$REGION"; then
                echo "âœ… S3 bucket created successfully"
                
                # Wait a moment for bucket to be ready
                sleep 5
                
                # Enable versioning
                echo "ğŸ”„ Enabling versioning..."
                aws s3api put-bucket-versioning \
                  --bucket "$BUCKET_NAME" \
                  --versioning-configuration Status=Enabled || echo "âš ï¸ Failed to enable versioning"
                
                # Enable server-side encryption
                echo "ğŸ”’ Enabling encryption..."
                aws s3api put-bucket-encryption \
                  --bucket "$BUCKET_NAME" \
                  --server-side-encryption-configuration '{
                    "Rules": [
                      {
                        "ApplyServerSideEncryptionByDefault": {
                          "SSEAlgorithm": "AES256"
                        }
                      }
                    ]
                  }' || echo "âš ï¸ Failed to enable encryption"
                
                # Block public access
                echo "ğŸ” Blocking public access..."
                aws s3api put-public-access-block \
                  --bucket "$BUCKET_NAME" \
                  --public-access-block-configuration \
                    BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true || echo "âš ï¸ Failed to block public access"
                
                echo "ğŸ”„ Retrying terraform initialization..."
                terraform init -input=false
              else
                echo "âŒ Failed to create S3 bucket"
                exit 1
              fi
            else
              echo "âŒ Bucket exists but terraform init still failed. Please check configuration."
              exit 1
            fi
          fi

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        run: terraform plan -no-color -input=false -out=plan.tfplan
        continue-on-error: true

      - name: Terraform Apply (Push - Testing)
        id: apply_push
        if: github.event_name == 'push' && github.ref == 'refs/heads/feat/aws-deployment'
        run: terraform apply -auto-approve -no-color -input=false

      - name: Terraform Apply (Manual)
        id: apply_manual
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply'
        run: terraform apply -auto-approve -no-color -input=false

      - name: Terraform Destroy
        id: destroy
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve -no-color -input=false

      - name: Get Terraform Outputs
        id: terraform_outputs
        if: (github.event_name == 'push' && github.ref == 'refs/heads/feat/aws-deployment') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          # Get EC2 public IP
          EC2_PUBLIC_IP=$(terraform output -raw ec2_public_ip 2>/dev/null || echo "")
          if [ -n "$EC2_PUBLIC_IP" ]; then
            echo "ec2_public_ip=$EC2_PUBLIC_IP" >> $GITHUB_OUTPUT
          fi

          # Get EC2 instance ID
          EC2_INSTANCE_ID=$(terraform output -raw ec2_instance_id 2>/dev/null || echo "")
          if [ -n "$EC2_INSTANCE_ID" ]; then
            echo "ec2_instance_id=$EC2_INSTANCE_ID" >> $GITHUB_OUTPUT
          fi

          # Check if infrastructure is properly deployed
          if [ -n "$EC2_PUBLIC_IP" ] && [ -n "$EC2_INSTANCE_ID" ]; then
            echo "infrastructure_deployed=true" >> $GITHUB_OUTPUT
          else
            echo "infrastructure_deployed=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify EC2 Instance State
        id: verify_instance
        if: steps.terraform_outputs.outputs.ec2_instance_id != ''
        run: |
          INSTANCE_ID="${{ steps.terraform_outputs.outputs.ec2_instance_id }}"
          INSTANCE_STATE=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text 2>/dev/null || echo "unknown")

          echo "instance_state=$INSTANCE_STATE" >> $GITHUB_OUTPUT

      - name: Capture Plan Output
        id: capture_plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        run: |
          terraform plan -no-color -input=false > plan.txt || true
          echo "stdout<<EOF" >> $GITHUB_OUTPUT
          cat plan.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "${{ steps.capture_plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 1. Retrieve existing bot comments for the PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            })
            const botComment = comments.find(comment => {
              return comment.user.type === 'Bot' && comment.body.includes('Terraform Format and Style')
            })

            // 2. Prepare format of the comment
            const output = `#### Terraform Format and Style ğŸ–Œ\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization âš™ï¸\`${{ steps.init.outcome }}\`
            #### Terraform Validation ğŸ¤–\`${{ steps.validate.outcome }}\`
            <details><summary>Validation Output</summary>

            \`\`\`\n
            ${{ steps.validate.outputs.stdout }}
            \`\`\`

            </details>

            #### Terraform Plan ğŸ“–\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`

            </details>

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`infra\`, Workflow: \`${{ github.workflow }}\`*`;

            // 3. If we have a comment, update it, otherwise create a new one
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: output
              })
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: output
              })
            }

      - name: Summary for Manual Run
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "## ğŸš€ Terraform Manual Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Action:** ${{ github.event.inputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Results:" >> $GITHUB_STEP_SUMMARY
          echo "- **Format Check:** ${{ steps.fmt.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Initialization:** ${{ steps.init.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation:** ${{ steps.validate.outcome }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.action }}" = "plan" ] || [ "${{ github.event.inputs.action }}" = "" ]; then
            echo "- **Plan:** ${{ steps.plan.outcome }}" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ github.event.inputs.action }}" = "apply" ]; then
            echo "- **Apply:** ${{ steps.apply_manual.outcome }}" >> $GITHUB_STEP_SUMMARY
            if [ -n "${{ steps.terraform_outputs.outputs.ec2_public_ip }}" ]; then
              echo "- **EC2 Public IP:** ${{ steps.terraform_outputs.outputs.ec2_public_ip }}" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -n "${{ steps.terraform_outputs.outputs.ec2_instance_id }}" ]; then
              echo "- **EC2 Instance ID:** ${{ steps.terraform_outputs.outputs.ec2_instance_id }}" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -n "${{ steps.verify_instance.outputs.instance_state }}" ]; then
              echo "- **Instance State:** ${{ steps.verify_instance.outputs.instance_state }}" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.apply_manual.outcome }}" = "success" ] && [ "${{ steps.terraform_outputs.outputs.infrastructure_deployed }}" = "true" ]; then
              echo "âœ… **Infrastructure deployment completed successfully!**" >> $GITHUB_STEP_SUMMARY
              echo "ğŸš€ **Ready for application deployment**" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ **Infrastructure deployment failed or incomplete. Please check the logs.**" >> $GITHUB_STEP_SUMMARY
            fi
          elif [ "${{ github.event.inputs.action }}" = "destroy" ]; then
            echo "- **Destroy:** ${{ steps.destroy.outcome }}" >> $GITHUB_STEP_SUMMARY
          fi

  # Trigger deployment workflow after successful infrastructure deployment
  trigger_deployment:
    name: Trigger Application Deployment
    runs-on: ubuntu-latest
    needs: terraform
    if: needs.terraform.outputs.infrastructure_deployed == 'true' && ((github.event_name == 'push' && github.ref == 'refs/heads/feat/aws-deployment') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply'))

    steps:
      - name: Trigger Deployment Workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const result = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy_aws.yml',
              ref: context.ref.replace('refs/heads/', '') // Use current branch
            });

            console.log('Triggered deployment workflow');
            console.log('Infrastructure outputs available:');
            console.log('- EC2 Public IP: ${{ needs.terraform.outputs.ec2_public_ip }}');
            console.log('- EC2 Instance ID: ${{ needs.terraform.outputs.ec2_instance_id }}');

      - name: Deployment Trigger Summary
        run: |
          echo "## ğŸš€ Deployment Trigger Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Automatically triggered application deployment**" >> $GITHUB_STEP_SUMMARY
          echo "**Target IP:** ${{ needs.terraform.outputs.ec2_public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**Instance ID:** ${{ needs.terraform.outputs.ec2_instance_id }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the [Actions tab](../../actions) for deployment progress." >> $GITHUB_STEP_SUMMARY
